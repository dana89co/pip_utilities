[
  {
    "objectID": "wbpip_gd_doc.html",
    "href": "wbpip_gd_doc.html",
    "title": "Group Data Documentation (wbpip)",
    "section": "",
    "text": "This document aims to describe the functions used in wbpip to calculated the poverty and inequality statistics using group data."
  },
  {
    "objectID": "wbpip_gd_doc.html#structure",
    "href": "wbpip_gd_doc.html#structure",
    "title": "Group Data Documentation (wbpip)",
    "section": "Structure",
    "text": "Structure\n\n\n\n\nflowchart RL\n    lz(select_lorenz) --&gt; stats[pip_stats]\n    lq(pip_stats_lq) --&gt; lz\n    lb(pip_stats_lb) --&gt; lz\n    \n    form_lq(functional_form_lq) --&gt; lq\n    est_lq(estimate_lq) --&gt; lq\n    fit_lq(fit_lq) --&gt; lq\n    \n    form_lb(functional_form_lb) --&gt; lb\n    est_lb(estimate_lb) --&gt; lb\n    fit_lb(fit_lb) --&gt; lb\n    derive_lb(derive_lb) ---&gt; lb\n    regres --&gt; lb\n    \n    check_val(check_curve_validity_lq) --&gt; est_lq\n    comp_dist_lq(compute_dist_stats_lq) --&gt; est_lq\n    comp_pov_lq(compute_pov_stats_lq) --&gt; est_lq\n    \n    check_val_lb(check_curve_validity_lb) --&gt; est_lb\n    derive_lb(derive_lb) ---&gt; check_val_lb\n    ddlk(ddlk) --&gt; check_val_lb\n    \n    comp_dist_lb(compute_dist_stats_lb) --&gt; est_lb\n    derive_lb --&gt; comp_dist_lb\n    value_at_lb --&gt; comp_dist_lb\n    compute_gini_lb --&gt; comp_dist_lb\n    value_at_lb --&gt; compute_gini_lb\n    compute_polarization_lb --&gt; comp_dist_lb\n    derive_lb --&gt; compute_polarization_lb\n    value_at_lb --&gt; compute_polarization_lb\n    compute_quantile_lb --&gt; comp_dist_lb\n    \n    comp_pov_lb(compute_pov_stats_lb) --&gt; est_lb\n    compute_headcount_lb --&gt; comp_pov_lb\n    rtSafe --&gt; compute_headcount_lb\n    funcD --&gt; rtSafe\n    rtNewt --&gt; rtSafe\n    BETAI --&gt; compute_headcount_lb\n    BETAICF --&gt; BETAI\n    GAMMLN --&gt; BETAI\n    compute_pov_gap_lb --&gt; comp_pov_lb\n    compute_pov_severity_lb --&gt; comp_pov_lb\n    \n    value_at_lb --&gt; fit_lb\n    \n    \n    polarization_lq(polarization_lq) --&gt; comp_dist_lq\n    gini_lq(gini_lq) --&gt; comp_dist_lq\n    value_at_lq --&gt; polarization_lq\n    value_at_lq(value_at_lq) --&gt; comp_dist_lq\n    mld_lq(&lt;b&gt;mld_lq&lt;/b&gt;) --&gt; comp_dist_lq\n    quantile_lq(&lt;b&gt;quantile_lq&lt;/b&gt;) --&gt; comp_dist_lq\n    derive_lq(derive_lq) --&gt; lq\n    derive_lq --&gt; comp_dist_lq\n    derive_lq --&gt; mld_lq\n    derive_lq --&gt; polarization_lq\n    value_at_lq --&gt; quantile_lq\n    \n    \n    style quantile_lq fill:#FFF1A2\n    style mld_lq fill:#FFF1A2"
  },
  {
    "objectID": "wbpip_gd_doc.html#functions",
    "href": "wbpip_gd_doc.html#functions",
    "title": "Group Data Documentation (wbpip)",
    "section": "1 Functions",
    "text": "1 Functions\n\n1.1 pip_stats\nDescription: Compute poverty statistics for grouped data by selecting the best functional fit for the Lorenz curve (either beta or quadratic)\n\n\nCode\ngd_compute_pip_stats &lt;- function(welfare,\n                                 povline,\n                                 population,\n                                 requested_mean,\n                                 popshare = NULL,\n                                 default_ppp = 1,\n                                 ppp = NULL,\n                                 p0 = 0.5) {\n\n\n  # Apply Lorenz quadratic fit ----------------------------------------------\n  results_lq &lt;- gd_compute_pip_stats_lq(\n    welfare = welfare,\n    population = population,\n    requested_mean = requested_mean,\n    povline = povline,\n    popshare = popshare,\n    default_ppp = default_ppp,\n    ppp = ppp,\n    p0 = p0\n  )\n\n  # Apply Lorenz beta fit ----------------------------------------------\n  results_lb &lt;- gd_compute_pip_stats_lb(\n    welfare = welfare,\n    population = population,\n    requested_mean = requested_mean,\n    povline = povline,\n    popshare = popshare,\n    default_ppp = default_ppp,\n    ppp = ppp,\n    p0 = p0\n  )\n\n\n  # Apply selection rules ---------------------------------------------------\n  out &lt;- gd_select_lorenz(\n    lq = results_lq,\n    lb = results_lb\n  )\n\n  # Return only subset of variables\n  out &lt;- out[c(\n    \"poverty_line\",\n    \"mean\",\n    \"median\",\n    \"headcount\",\n    \"poverty_gap\",\n    \"poverty_severity\",\n    \"watts\",\n    \"gini\",\n    \"mld\",\n    \"polarization\",\n    \"deciles\"\n  )]\n\n\n  return(out)\n}\n\n\n\n\n\n\n\n\nIssue: Boundary conditions\n\n\n\nAt the moment, this is calculated using \\((\\mu L'(0.001) + 4,\\mu L'(0.98) - 4)\\) (Note: Not sure what is the reason of adding and subtracting 4).\n\n\n\n\n1.2 select_lorenz\nDescription: Select best Lorenz fit and adjust the returned statistics if needed.\n\n\nCode\ngd_select_lorenz &lt;- function(lq, lb) {\n\n  # Set default value\n  datamean &lt;- lq[[\"mean\"]]\n  is_valid &lt;- lq[[\"is_valid\"]] | lb[[\"is_valid\"]]\n  is_normal &lt;- lq[[\"is_normal\"]] | lb[[\"is_normal\"]]\n\n  # Selection of Lorenz fit for poverty statistics\n  use_lq_for_pov &lt;- use_lq_for_poverty(\n    lq = lq,\n    lb = lb\n  )\n\n  # Selection of Lorenz fit for distributional statistics\n  use_lq_for_dist &lt;- use_lq_for_distributional(\n    lq = lq,\n    lb = lb\n  )\n\n  # Retrieve distributional statistics\n  dist &lt;- retrieve_distributional(\n    lq = lq,\n    lb = lb,\n    is_valid = is_valid,\n    use_lq_for_dist = use_lq_for_dist\n  )\n\n  # Retrieve poverty statistics\n  pov &lt;- retrieve_poverty(\n    lq = lq,\n    lb = lb,\n    is_normal = is_normal,\n    use_lq_for_pov = use_lq_for_pov\n  )\n\n  return(list(\n    mean             = datamean,\n    poverty_line     = pov[[\"poverty_line\"]],\n    z_min            = dist[[\"z_min\"]],\n    z_max            = dist[[\"z_max\"]],\n    # ppp            = lq[[\"ppp\"]],\n    gini             = dist[[\"gini\"]],\n    median           = dist[[\"median\"]],\n    # rmed           = rmed,\n    rmhalf           = dist[[\"rmhalf\"]],\n    polarization     = dist[[\"polarization\"]],\n    ris              = dist[[\"ris\"]],\n    mld              = dist[[\"mld\"]],\n    dcm              = lq[[\"dcm\"]],\n    deciles          = dist[[\"deciles\"]],\n    headcount        = pov[[\"headcount\"]],\n    poverty_gap      = pov[[\"poverty_gap\"]],\n    poverty_severity = pov[[\"poverty_severity\"]],\n    eh               = pov[[\"eh\"]],\n    epg              = pov[[\"epg\"]],\n    ep               = pov[[\"ep\"]],\n    gh               = pov[[\"gh\"]],\n    gpg              = pov[[\"gpg\"]],\n    gp               = pov[[\"gp\"]],\n    watts            = pov[[\"watts\"]],\n    sse              = dist[[\"sse\"]]\n  ))\n}\n\n\n\n\n1.3 pip_stats_lq\nDescription: Compute poverty statistics for grouped data using the quadratic functional form of the Lorenz qurve.\n\n\nCode\ngd_compute_pip_stats_lq &lt;- function(welfare,\n                                    povline,\n                                    population,\n                                    requested_mean,\n                                    popshare = NULL,\n                                    default_ppp,\n                                    ppp = NULL,\n                                    p0 = 0.5) {\n\n  # Adjust mean if different PPP value is provided\n  if (!is.null(ppp)) {\n    requested_mean &lt;- requested_mean * default_ppp / ppp\n  } else {\n    ppp &lt;- default_ppp\n  }\n  # STEP 1: Prep data to fit functional form\n  prepped_data &lt;- create_functional_form_lq(\n    welfare = welfare,\n    population = population\n  )\n\n  # STEP 2: Estimate regression coefficients using LQ parameterization\n  reg_results &lt;- regres(prepped_data, is_lq = TRUE)\n  reg_coef &lt;- reg_results$coef\n\n  A &lt;- reg_coef[1]\n  B &lt;- reg_coef[2]\n  C &lt;- reg_coef[3]\n\n  # Step 2.1: pre-calculate key values\n  kv &lt;- gd_lq_key_values(A, B, C)\n\n  # OPTIONAL: Only when popshare is supplied\n  # return poverty line if share of population living in poverty is supplied\n  # intead of a poverty line\n  if (!is.null(popshare)) {\n    povline &lt;- derive_lq(popshare,\n                         A, B, C,\n                         key_values = kv) * requested_mean\n  }\n\n  # Boundary conditions (Why 4?)\n  z_min &lt;- requested_mean * derive_lq(0.001,\n                                      A, B, C,\n                                      key_values = kv) + 4\n  z_max &lt;- requested_mean * derive_lq(0.980,\n                                      A, B, C,\n                                      key_values = kv) - 4\n  z_min &lt;- if (z_min &lt; 0) 0L else z_min\n\n  results1 &lt;- list(requested_mean, povline, z_min, z_max, ppp)\n  names(results1) &lt;- list(\"mean\", \"poverty_line\", \"z_min\", \"z_max\", \"ppp\")\n\n  # STEP 3: Estimate poverty measures based on identified parameters\n  results2 &lt;- gd_estimate_lq(requested_mean, povline, p0,\n                             A, B, C, key_values = kv)\n\n  # STEP 4: Compute measure of regression fit\n  results_fit &lt;- gd_compute_fit_lq(welfare,\n                                   population,\n                                   results2$headcount,\n                                   A, B, C,\n                                   key_values = kv)\n\n  res &lt;- c(results1,\n           results2,\n           results_fit,\n           reg_results)\n\n  return(res)\n}\n\n\n\n\n1.4 functional_form_lq\nDescription: Prepares data for regression of \\(y(1-y)\\) on \\((x^2-y)\\), \\(y(x-1)\\) and \\((x-y)\\).\n\n\nCode\ncreate_functional_form_lq &lt;- function(welfare,\n                                      population) {\n  # CHECK inputs\n  # assertthat::assert_that(is.numeric(population))\n  # assertthat::assert_that(is.numeric(welfare))\n  # assertthat::assert_that(length(population) == length(welfare))\n  # assertthat::assert_that(length(population) &gt; 1)\n\n  # Remove last observation (the functional form for the Lorenz curve already forces\n  # it to pass through the point (1, 1)\n  nobs &lt;- length(population) - 1\n  population &lt;- population[1:nobs]\n  welfare &lt;- welfare[1:nobs]\n\n  # L(1-L)\n  y &lt;- welfare * (1 - welfare)\n  # (P^2-L)\n  x1 &lt;- population^2 - welfare\n  # L(P-1)\n  x2 &lt;- welfare * (population - 1)\n  # P-L\n  x3 &lt;- population - welfare\n\n  return(list(y = y, X = cbind(x1, x2, x3)))\n\n}\n\n\nNote: The last observation of (x,y), which by construction has the value (1, 1), is excluded since the functional form for the Lorenz curve already forces it to pass through the point (1, 1).\nReferences: [1]\nRelevant equations:\nThe general Quadratic Lorenz curve form is:\n\\[ax^2 + bxy + cy^2 + dx + ey + f = 0 \\tag{1}\\]\nwhere \\(y\\) is the vector of cumulative proportion of consumption/income (L) and \\(x\\) is the cumulative proportions of population (P). Using the conditions \\(f=0\\) and \\(e = -(a+b+d+1)\\) the previous equation is rewritten in a linear form as follows (Equation 15 in Villasenor et al, 1989):\n\\[y(1-y) = a(x^2-y) + by(x-1) + d(x-y) \\tag{2}\\]\nThis function prepares data to estimate \\(a\\), \\(b\\), and \\(d\\) (Note: \\(d\\) is named \\(C\\) in wbpip).\n\n\n1.5 value_at_lq\nDescription: Solves for the Quadratic Lorenz curves.\n\n\nCode\nvalue_at_lq &lt;- function(x, A, B, C, key_values) {\n\n  # Check for NA, Inf and negative values in x\n  check_NA_Inf_values(x)\n  check_neg_values(x)\n\n  # Calculations\n  # e &lt;- -(A + B + C + 1)\n  # m &lt;- (B^2) - (4 * A)\n  # n &lt;- (2 * B * e) - (4 * C)\n  temp &lt;- (key_values$m * x^2) + (key_values$n * x) + (key_values$e^2)\n  temp[temp &lt; 0] &lt;- 0\n\n  # Solving the equation of the Lorenz curve\n  estle &lt;- -0.5 * ((B * x) + key_values$e + sqrt(temp))\n\n  return(estle)\n}\n\n\nReferences: [1]\nRelevant equations:\nThis function calculates the value at the Quadratic Lorenz Curve. Solving Equation 1 for \\(y\\), and assuming \\(f=0\\) and \\(e = -(a+b+d+1)\\) the density function that better fits income distributions will be (Equation 6b in Villasenor et al, 1989):\n\\[ y= \\Bigl\\{-(bx+e) - (\\alpha x^2 + \\beta x + e^2)^\\frac{1}{2}\\Bigl\\}/2 \\tag{3}\\]\nwhere \\(\\alpha = b^2 -4a\\) and \\(\\beta = 2be - 4d\\).\n\n\n1.6 derive_lq\nDescription: returns the first derivative of the quadratic Lorenz curves with \\(c = 1\\).\n\n\nCode\nderive_lq &lt;- function(x, A, B, C, key_values) {\n\n  if (is.null(key_values)) {\n    key_values &lt;- gd_lq_key_values(A, B, C)\n    # e          &lt;- key_values$e\n    # m          &lt;- key_values$m\n    # n          &lt;- key_values$n\n  }\n\n  if (anyNA(x) == TRUE) {\n    cli::cli_abort(\"`x' must be a numeric or integer vector\")\n  }\n  # note:\n  #   alpha --&gt; m\n  #   beta  --&gt; n\n\n  # e &lt;- -(A + B + C + 1)\n  # m &lt;- (B^2) - (4 * A)\n  # n &lt;- (2 * B * e) - (4 * C) # C is called D in original paper, but C in Datt paper\n  tmp &lt;- (key_values$m * x^2) + (key_values$n * x) + (key_values$e^2)\n  tmp[(!is.na(tmp) & tmp &lt; 0)] &lt;- 0 # If tmp == 0, val = Inf.\n\n  # Formula for first derivative of GQ Lorenz Curve\n  val &lt;- -(B / 2) - ((2 * key_values$m * x + key_values$n) / (4 * sqrt(tmp)))\n\n  return(val)\n}\n\n\nReferences: [1]\nRelevant equations:\nThis function computes the first derivative of Equation 3:\n\\[-(b / 2) - (\\beta + 2 \\alpha x) / (4\\sqrt(\\alpha x^2 + \\beta x + e^2) \\tag{4}\\]\n\n\n1.7 estimate_lq\nDescription: Estimates poverty and inequality stats from Quadratic Lorenz fit\n\n\nCode\ngd_estimate_lq &lt;- function(mean, povline, p0, A, B, C, key_values) {\n\n  if (is.null(key_values)) {\n    key_values &lt;- gd_lq_key_values(A, B, C)\n  }\n  e  &lt;- key_values$e\n  m  &lt;- key_values$m\n  n  &lt;- key_values$n\n  r  &lt;- key_values$r\n  s1 &lt;- key_values$s1\n  s2 &lt;- key_values$s2\n\n  validity &lt;- check_curve_validity_lq(A, B, C, key_values = key_values)\n                                      #e, m, n, r^2)\n  if (validity$is_valid == FALSE & validity$is_normal == FALSE) {\n    return(empty_gd_compute_pip_stats_response)\n  }\n\n  # Compute distributional measures -----------------------------------------\n  dist_stats &lt;- gd_compute_dist_stats_lq(mean, p0, A, B, C, key_values = key_values)\n\n  # Compute poverty stats ---------------------------------------------------\n  pov_stats  &lt;- gd_compute_poverty_stats_lq(mean, povline, A, B, C, key_values = key_values)\n\n  out &lt;- list(\n    gini = dist_stats$gini,\n    median = dist_stats$median,\n    rmhalf = dist_stats$rmhalf,\n    polarization = dist_stats$polarization,\n    ris = dist_stats$ris,\n    mld = dist_stats$mld,\n    dcm = dist_stats$dcm,\n    deciles = dist_stats$deciles,\n    headcount = pov_stats$headcount,\n    poverty_gap = pov_stats$pg,\n    poverty_severity = pov_stats$p2,\n    eh = pov_stats$eh,\n    epg = pov_stats$epg,\n    ep = pov_stats$ep,\n    gh = pov_stats$gh,\n    gpg = pov_stats$gpg,\n    gp = pov_stats$gp,\n    watts = pov_stats$watts,\n    dl = pov_stats$dl,\n    ddl = pov_stats$ddl,\n    is_normal = validity$is_normal,\n    is_valid = validity$is_valid\n  )\n\n  return(out)\n}\n\n\n\n\n1.8 check_curve_validity_lq\nDescription: Check validity of Lorenz Quadratic fit\n\n\nCode\ncheck_curve_validity_lq &lt;- function(A, B, C, key_values) {\n  is_normal &lt;- FALSE\n  is_valid &lt;- FALSE\n  r &lt;- (key_values$r)^2 # formerly, the input to the func was r^2\n\n  # r needs to be &gt; 0 because need to extract sq root\n  if (r &lt; 0) { # now that r is squared, this will never be TRUE\n    return(list( # but r^2 was used as input before `key_values` so\n      is_normal = is_normal, # this was already never executed\n      is_valid = is_valid\n    ))\n  }\n\n  if (key_values$e &gt; 0 || C &lt; 0) {\n    return(list(\n      is_normal = is_normal,\n      is_valid = is_valid\n    ))\n  }\n\n  # Failure conditions for checking theoretically valid Lorenz curve\n  # Found in section 4 of Datt computational tools paper\n  cn1 &lt;- key_values$n^2\n  cn3 &lt;- cn1 / (4 * key_values$e^2)\n\n  if (!((key_values$m &lt; 0) |\n    ((key_values$m &gt; 0) & (key_values$m &lt; cn3) & (key_values$n &gt;= 0)) |\n    ((key_values$m &gt; 0) & (key_values$m &lt; -key_values$n / 2) & (key_values$m &lt; cn3)))) {\n    return(list(\n      is_normal = is_normal,\n      is_valid = is_valid\n    ))\n  }\n\n  is_normal &lt;- TRUE\n  is_valid &lt;- (A + C) &gt;= 0.9\n\n  return(list(\n    is_normal = is_normal,\n    is_valid  = is_valid\n  ))\n}\n\n\nReferences: [1], [2], [3]\nRelevant equations:\nThe function tests for specific assumptions for the Lorenz Quadratic and relies on the formulas from Table 2 in Datt, G (1998) [3]. The nomenclature for some of these formulas differ from Villasenor et al (1989), so this is how they match:\n\\(m = \\alpha = b^2 -4a\\)\n\\(n = \\beta = 2be -4c\\) (\\(c=d\\) for Villasenor et al, 1989)\n\\(r = K*2\\alpha = (n^2 - 4me^2)^\\frac{1}{2}\\)\n\n\n\n\n\n\nIssue: Rename \\(r\\)\n\n\n\nAt the moment, \\(r\\) refers to \\((n^2 - 4me^2)\\) in wbpip. This is already fixed on commit 47852c in branch fix_key_values by Zander (Waiting for merge). We should maybe rename this within this function.\n\n\nThe conditions this function tests are presented in Section 4 of Datt (1998):\nNormality and Validity\n\n\\((n^2 - 4me^2)&gt;0\\) so the square root in \\(r\\) to be positive. (Normality and validity)\n\\(e&lt;0\\) or \\(c&gt;0\\) so \\(L(0,y) = 0\\) and \\(L'(0^{+},y) \\geq 0\\) (Normality and validity)\n\\(a+d \\geq 0.9\\) so \\(L(1,y) = 1\\) (Validity)\n\n\n\n\n\n\n\nIssue: The inequality for \\(a+d\\)\n\n\n\nAt the moment, most test are design for the old validation \\(a+d \\leq 1\\). However, the Corrigendum of the original paper [2] indicates we should use \\(a+d \\geq 1\\)\n\n\nAnd so \\(L''(x,y) \\geq 0\\) for \\(x\\) within \\((0,1)\\):\n\n\\(m &lt; 0\\) (condition on Villasenor et al., 1989)\nif \\(m &gt; 0\\) then \\(m &lt; n^2/4 e^2\\) and \\(n \\leq 0\\) (last condition from Datt,1998)\nif \\(m &gt; 0\\) then \\(m &lt; n^2/4 e^2\\) and \\(m &lt; -n/2\\) (last condition from Datt,1998)\n\n\\(L''(x,y)\\) can be calculated using Equation 4:\n\\[ \\frac{\\beta^2 -4\\alpha e^2}{8(\\alpha x^2 + \\beta x + e^2)^\\frac{3}{2}} = \\frac{n^2 - 4me^2}{8(mx^2 +nx +e^2)^\\frac{3}{2}}=\\frac{r^2}{8(mx^2 +nx +e^2)^\\frac{3}{2}} \\]\n\n\n1.9 compute_dist_stats_lq\nDescription: Computes distributional stats from Lorenz Quadratic fit\n\n\nCode\ngd_compute_dist_stats_lq &lt;- function(mean, p0, A, B, C, key_values = key_values) {\n\n  gini    &lt;- gd_compute_gini_lq(A, B, C,\n                                key_values = key_values)\n  median  &lt;- mean * derive_lq(0.5, A, B, C,\n                              key_values = key_values)\n  rmhalf  &lt;- value_at_lq(p0, A, B, C,\n                         key_values = key_values) * mean / p0 # What is this??\n  dcm     &lt;- (1 - gini) * mean\n  pol     &lt;- gd_compute_polarization_lq(mean, p0, dcm, A, B, C,\n                                        key_values = key_values)\n  ris     &lt;- value_at_lq(0.5, A, B, C,\n                         key_values = key_values)\n  mld     &lt;- gd_compute_mld_lq(A, B, C,\n                               key_values = key_values)\n  deciles &lt;- gd_compute_quantile_lq(A, B, C,\n                                    key_values = key_values)\n\n  return(list(\n    gini         = gini,\n    median       = median,\n    rmhalf       = rmhalf,\n    dcm          = dcm,\n    polarization = pol,\n    ris          = ris,\n    mld          = mld,\n    deciles      = deciles\n  ))\n}\n\n\n\n\n\n\n\n\nCheck:\n\n\n\nWhat is the difference with gd_estimate_dist_stats_lq?\n\n\n\n\n1.10 quantile_lq\nDescription: Compute quantiles from Lorenz Quandratic fit\n\n\nCode\nold_gd_compute_quantile_lq &lt;- function(A, B, C, n_quantile = 10) {\n  vec &lt;- vector(mode = \"numeric\", length = n_quantile)\n  x1 &lt;- 1 / n_quantile\n  q &lt;- 0L\n  lastq &lt;- 0L\n  for (i in seq_len(n_quantile - 1)) {\n    q &lt;- value_at_lq(x1, A, B, C)\n    v &lt;- q - lastq\n    vec[i] &lt;- v\n    lastq &lt;- q\n    x1 &lt;- x1 + 1 / n_quantile\n  }\n  vec[n_quantile] &lt;- 1 - lastq\n\n  return(vec)\n}\n\n\nNote: This function calculates the quantiles for a Lorenz Quadratic with specific values for \\(a\\), \\(b\\) and \\(d\\).\n\n\n\n\n\n\nIssues:\n\n\n\nThe description of this function indicates that it calculates the quantiles (deciles) for the density for some specific values of \\(a\\), \\(b\\) and \\(d\\), but it calculates instead the “share” or the value between the deciles. If I understand correctly, the density is the lorenz curve and the share will refer to the deciles of the welfare vector.\nRegarding the last decile, they manually calculated it by subtracting 1 to the second-to-last decile:\nvec[n_quantile] &lt;- 1 - value_at_lq(x[n_quantile-1], A, B, C) where n_quantile = 10\nHowever, my hypothesis is that this is related to Issue: The inequality for \\(a+d\\) above. If \\(A+C \\geq 1\\) then value_at_lq(1, A, B, C) = 1. We can see the case in this Desmos graph.\n\n\nMy version of the code:\n\n\nCode\ngd_compute_quantile_lq &lt;- function(A, B, C, n_quantile = 10) {\n\n  x   &lt;- seq(from = 1/n_quantile, to = 1, by = 1/n_quantile)\n\n  vec &lt;- diff(c(0,value_at_lq(x, A, B, C)))\n\n  vec[n_quantile] &lt;- 1- value_at_lq(x[n_quantile-1], A, B, C) # Is this correct?\n\n  return(vec)\n}\n\n\n\n\n1.11 mld_lq\nDescription: Computes Mean Log Deviation from Lorenz Quadratic fit\n\n\nCode\nold_gd_compute_mld_lq &lt;- function(A, B, C) {\n  x1 &lt;- derive_lq(0.0005, A, B, C)\n  gap &lt;- 0L\n  mld &lt;- 0L\n  if (x1 == 0) {\n    gap &lt;- 0.0005\n  } else {\n    mld &lt;- suppressWarnings(log(x1) * 0.001)\n  }\n  x1 &lt;- derive_lq(0, A, B, C)\n  for (xstep in seq(0, 0.998, 0.001)) {\n    x2 &lt;- derive_lq(xstep + 0.001, A, B, C)\n    if ((x1 &lt;= 0) || (x2 &lt;= 0)) {\n      gap &lt;- gap + 0.001\n      if (gap &gt; 0.5) {\n        return(-1)\n      }\n    } else {\n      gap &lt;- 0L\n      mld &lt;- mld + (log(x1) + log(x2)) * 0.0005\n    }\n    x1 &lt;- x2\n  }\n  return(-mld)\n}\n\n\nReferences: None\nNote: In this function, they do not describe how the function is calculated. The following is my hypothesis of what they were trying to accomplish:\nRelevant equations:\nThe mean log deviation:\n\\[-\\frac{1}{N} \\sum_{i=1}^N ln(\\frac{y_i}{\\mu})=-\\frac{1}{N} \\sum_{i=1}^N ln(\\frac{y_i}{\\frac{1}{N}\\sum_{i=1}^N y_i}) \\]\nUsing the derivation from Rohde (2008) (Equation 15.20), we know that:\n\\[L'(\\pi) = \\frac{N y_k}{\\sum_{k=1}^N y_k}\\]\nwhere \\(y_k\\) is the income accruing to the \\(k_{th}\\) individual if ordered such that \\(y_1&lt;y_2&lt;...&lt;y_k\\) and \\(\\pi= \\frac{k}{j}\\). Then the mean log deviation can be rewritten as (Equation 15.21):\n\\[-\\int_0^1 ln(L'(\\pi))d\\pi= \\lim_{n \\rightarrow \\infty} -\\sum_{i=1}^{N}\\frac{1}{N}ln(\\frac{N y_k}{\\sum_{k=1}^N y_k})\\]\n\n\n\n\n\n\nIssue:\n\n\n\nMy hypothesis is that they used the last formula to calculate the Mean Log Deviation. I am still unsure why they used some rules at the lower end, more specifically why they return \\(1\\) if for the left tail of \\(y\\) we encounter negative values.\n\n\nMy version of the code:\n\n\nCode\ngd_compute_mld_lq &lt;- function(A, B, C) {\n  x1 &lt;- derive_lq(0.0005, A, B, C) \n  mld &lt;- 0L\n  if (x1 != 0) { \n    mld &lt;- suppressWarnings(log(x1) * 0.001) # Needed to match test\n  }\n\n  xstep &lt;- seq(0, 0.999, 0.001)\n  x &lt;- derive_lq(xstep, A, B, C)\n\n  if (any(x[1:33]&lt;=0)){ # To account for negative values \n    return(-1)\n  }else{\n    mld &lt;- mld + fsum( (log(x[1:999])+log(x[2:1000])) *0.0005) \n    return(-mld)\n  }\n}\n\n\n\n\n1.12 gini_lq\nDescription: Compute Gini index from Lorenz Quadratic fit.\n\n\nCode\ngd_compute_gini_lq &lt;- function(A, B, C, key_values) {\n\n  # For the GQ Lorenz curve, the Gini formula are valid under the condition A+C&gt;=1\n  # P.isValid &lt;- (A + C) &gt;= 0.9\n  # P.isNormal &lt;- TRUE\n\n  e1 &lt;- abs(A + C - 1)\n  e2 &lt;- 1 + (B / 2) + key_values$e\n\n  tmp1 &lt;- key_values$n * (B + 2) / (4 * key_values$m)\n  tmp2 &lt;- (key_values$r^2) / (8 * key_values$m)\n  tmp3 &lt;- (2 * key_values$m) + key_values$n\n\n  if (key_values$m &gt; 0) {\n    # tmpnum &lt;- tmp3 + 2 * sqrt(m) * abs(e)\n    # tmpden &lt;- n - 2 * abs(e) * sqrt(m)\n\n    # Formula from Datt paper\n    # CHECK that code matches formulas in paper\n    gini &lt;- e2 + (tmp3 / (4 * key_values$m)) * e1 - (key_values$n * abs(key_values$e) / (4 * key_values$m)) - ((key_values$r^2) / (8 * sqrt(key_values$m)^3)) *\n      log(abs(((tmp3 + (2 * sqrt(key_values$m) * e1))) / (key_values$n + (2 * sqrt(key_values$m) * abs(key_values$e)))))\n    # P.gi &lt;- (e/2) - tmp1 - (tmp2 * log(abs(tmpnum/tmpden)) / sqrt(m))\n  } else {\n    tmp4 &lt;- ((2 * key_values$m) + key_values$n) / key_values$r\n    tmp4 &lt;- if (tmp4 &lt; -1) -1 else tmp4\n    tmp4 &lt;- if (tmp4 &gt; 1) 1 else tmp4\n\n    # Formula does not match with paper\n    gini &lt;- e2 +\n      (tmp3 / (4 * key_values$m)) *\n      e1 - (key_values$n * abs(key_values$e) / (4 * key_values$m)) +\n      (tmp2 * (asin(tmp4) - asin(key_values$n / key_values$r)) / sqrt(-key_values$m))\n    # P.gi &lt;- (e/2) - tmp1 + ((tmp2 * (asin(tmp4) - asin(n/r))) / sqrt(-m))\n  }\n\n  return(gini)\n}\n\n\nReferences: [3]\nRelevant equations:\n\nif \\(m&lt;0\\):\n\n\\[ \\frac{e}{2} - \\frac{n (b+2)}{4m} + \\frac{r^2}{8m\\sqrt{-m}}\\left[ \\sin^{-1} \\frac{2 + n}{r} - \\sin^{-1} \\frac{2 + n}{r} \\right]\\]\n\nif \\(m&gt;0\\):\n\n\\[  \\frac{e}{2} - \\frac{n (b+2)}{4m} - \\frac{r^2}{8m\\sqrt{m}} \\ln \\left[\\left|{\\frac{2m+n+2\\sqrt{m} (a+c-1)}{n-2e\\sqrt{m}}}\\right| \\right] \\]\n\n\n1.13 polarization_lq\nDescription: Computes polarization index from parametric Lorenz fit\nReferences: …\nRelevant equations: …\n\n\n1.14 pip_stats_lb\nDescription: Compute poverty statistics for grouped data using the beta functional form of the Lorenz qurve.\n\n\nCode\ngd_compute_pip_stats_lb &lt;- function(welfare,\n                                    povline,\n                                    population,\n                                    requested_mean,\n                                    popshare = NULL,\n                                    default_ppp,\n                                    ppp = NULL,\n                                    p0 = 0.5) {\n\n  # Adjust mean if different PPP value is provided\n  if (!is.null(ppp)) {\n    requested_mean &lt;- requested_mean * default_ppp / ppp\n  } else {\n    ppp &lt;- default_ppp\n  }\n  # STEP 1: Prep data to fit functional form\n  prepped_data &lt;- create_functional_form_lb(\n    welfare = welfare,\n    population = population\n  )\n\n  # STEP 2: Estimate regression coefficients using LB parameterization\n  reg_results &lt;- regres(prepped_data, is_lq = FALSE)\n  reg_coef &lt;- reg_results$coef\n\n  A &lt;- reg_coef[1]\n  B &lt;- reg_coef[2]\n  C &lt;- reg_coef[3]\n\n  # OPTIONAL: Only when popshare is supplied\n  # return poverty line if share of population living in poverty is supplied\n  # instead of a poverty line\n\n  if (!is.null(popshare)) {\n    povline &lt;- derive_lb(popshare, A, B, C) * requested_mean\n  }\n\n  # Boundary conditions (Why 4?)\n  z_min &lt;- requested_mean * derive_lb(0.001, A, B, C) + 4\n  z_max &lt;- requested_mean * derive_lb(0.980, A, B, C) - 4\n  z_min &lt;- if (z_min &lt; 0) 0L else z_min\n\n  results1 &lt;- list(requested_mean, povline, z_min, z_max, ppp)\n  names(results1) &lt;- list(\"mean\", \"poverty_line\", \"z_min\", \"z_max\", \"ppp\")\n\n  # STEP 3: Estimate poverty measures based on identified parameters\n  results2 &lt;- gd_estimate_lb(requested_mean, povline, p0, A, B, C)\n\n  # STEP 4: Compute measure of regression fit\n  results_fit &lt;- gd_compute_fit_lb(welfare, population, results2$headcount, A, B, C)\n\n  res &lt;- c(results1, results2, results_fit, reg_results)\n\n  return(res)\n}\n\n\n\n\n1.15 functional_form_lb\nDescription: Prepare data for Lorenz beta regression: \\(Log(L(p) - p) = \\log(a) + \\alpha \\log(p) + \\beta \\log(1 - p)\\).\n\n\nCode\ncreate_functional_form_lb &lt;- function(welfare, population) {\n  # CHECK inputs\n  # assertthat::assert_that(is.numeric(population))\n  # assertthat::assert_that(is.numeric(welfare))\n  # assertthat::assert_that(length(population) == length(welfare))\n  # assertthat::assert_that(length(population) &gt; 1)\n\n  # Remove last observation (the functional form for the Lorenz curve already forces\n  # it to pass through the point (1, 1)\n  nobs &lt;- length(population) - 1\n  population &lt;- population[1:nobs]\n  welfare &lt;- welfare[1:nobs]\n\n  # y\n  y &lt;- log(population - welfare)\n  # x1\n  x1 &lt;- 1L\n  # x2\n  x2 &lt;- log(population)\n  # x3\n  x3 &lt;- log(1 - population)\n\n  return(list(y = y, X = cbind(x1, x2, x3)))\n\n}\n\n\nReferences: [5], [3]\nNote: The last observation of (p,l), which by construction has the value (1, 1), is excluded since the functional form for the Lorenz curve already forces it to pass through the point (1, 1).\nRelevant equations:\nThe general Beta Lorenz curve (Kakwani, 1980) form is: \\[ L(p) = p - a p^\\alpha (1-p)^\\beta \\tag{5}\\]\nwhere \\(L(p)\\) is the vector of cumulative proportion of consumption/income and \\(p\\) is the cumulative proportions of population. They correspond to \\(y\\) and \\(x\\) in the Quadratic Lorenz form.\nNote that in Datt (1998), the parameters have different letters: \\[ L(p) = p - \\theta p^\\gamma (1-p)^\\delta \\tag{6}\\]\nIn our code, the parameters are addressed respectively as: $$\n\\[\\begin{aligned}\nA = a = \\theta \\\\\n\nB = \\alpha = \\gamma \\\\\n\nC = \\beta = \\delta\n\\end{aligned}\\]\n$$\nThe previous equation is logged and rewritten as follows: $$\n\\[\\begin{aligned}\nL(p) = p - a p^\\alpha (1-p)^\\beta \\\\\n\nL(p) - p = - a p^\\alpha (1-p)^\\beta \\\\\n\np - L(p) = a p^\\alpha (1-p)^\\beta \\\\\n\nLog(p - L(p)) =\n\n\\log(L(p) - p) = \\log(a) + \\alpha \\log(p) + \\beta \\log(1 - p)\n\n\\end{aligned}\\]\n$$ ### value_at_lb Description: Solves for the Beta Lorenz curve.\n\n\nCode\nvalue_at_lb &lt;- function(x, A, B, C) {\n\n  # Check for NA, Inf and negative values in x\n  check_NA_Inf_values(x)\n  check_neg_values(x)\n\n  out &lt;- x - (A * (x^B) * ((1 - x)^C))\n\n  return(out)\n}\n\n\nReferences: [5]\nThis function calculates the value at the Beta Lorenz Curve. It solves Equation 5 for \\(L(p)\\).\n\n\n1.16 derive_lb\nDescription: returns the first derivative of the Beta Lorenz curves.\n\n\nCode\nderive_lb &lt;- function(x, A, B, C) {\n  val &lt;- vector(\"numeric\", length(x))\n  val[x == 0] &lt;- -Inf\n  val[x == 1] &lt;- Inf\n\n  if (B == 1) {\n      val[x == 0] &lt;- 1 - A\n    }\n    if (B &gt; 1) {\n      val[x == 0] &lt;- 1\n    }\n    if (C == 1) {\n      val[x == 1] &lt;- 1 + A\n    }\n    if (C &gt; 1) {\n      val[x == 1] &lt;- 1\n    } else {\n\n      # Formula for first derivative of GQ Lorenz Curve\n      new_x &lt;- x[!(x %in% c(0,1))]\n      val[!(x %in% c(0,1))] &lt;- 1 - ((A * new_x^B) * ((1 - new_x)^C) * ((B / new_x) -( C / (1 - new_x)) ) )\n    }\n  return(val)\n}\n\n\nReferences: [3]\nRelevant equations:\nAs noted above, in our code, the parameters are addressed respectively as: $$\n\\[\\begin{aligned}\nA = a = \\theta \\\\\n\nB = \\alpha = \\gamma \\\\\n\nC = \\beta = \\delta\n\\end{aligned}\\]\n$$\nAdditionally, \\(p = x\\) and \\(L(p) = y\\). We will use the code notation for practicality.\nThis function computes the first derivative of Equation 5, which is derived as follows:\n\\[\\begin{aligned}\ny &= x - A x^B (1-x)^C \\\\\ny' &= a A (1-x)^{C-1} x^B - AB(1-x)^C x^{B-1} + 1\\\\\n&= 1 - A (1-x)^C x^B \\left[\\frac{C}{1-x} - \\frac{B}{x}\\right]\n\\end{aligned}\\]\n\n\n\n\n\n\nIssues:\n\n\n\nThere are a series of boundary conditions for the first derivative, but I cannot find the reason for those boundary conditions in the literature. The conditions are the following:\n\nat \\(x = 0\\):\n\nif \\(B = 1\\) -&gt; \\(1 - A\\)\nif \\(B &gt; 1\\) -&gt; \\(1\\)\n\nat \\(x = 1\\):\n\nif \\(C = 1\\) -&gt; \\(1 + A\\)\nif \\(C &gt; 1\\) -&gt; \\(1\\)\n\n\nAccording to Kakwani (1980) and the rest of the literature, the only condition for \\(L'(x) = y'\\) is to be \\(&gt;=0\\) at \\(x = 0\\). Now, if we follow the execution of the function, it is true that when \\(x=0\\), \\(\\frac{B}{X} = \\frac{B}{0} = undefined\\),which would cause calculation issues, but the rest of the derivative already sets \\(L'(x) = 1\\), so it is not clear to me why we have to set it to \\(1-A\\) or \\(1\\). The same sort of reasoning applies at \\(x = 1\\), but with the parameter \\(C\\).\n\n\n\n\n1.17 estimate_lb\nDescription: Estimates poverty and inequality stats from the Beta Lorenz fit.\n\n\nCode\ngd_estimate_lb &lt;- function(mean, povline, p0, A, B, C) {\n\n  # Compute distributional measures\n  dist_stats &lt;- gd_compute_dist_stats_lb(mean, p0, A, B, C)\n\n  # Compute poverty stats\n  pov_stats &lt;- gd_compute_poverty_stats_lb(mean, povline, A, B, C)\n\n  # Check validity\n  validity &lt;- check_curve_validity_lb(headcount = pov_stats[[\"headcount\"]], A, B, C)\n\n  out &lt;- list(\n    gini = dist_stats$gini,\n    median = dist_stats$median,\n    rmhalf = dist_stats$rmhalf,\n    polarization = dist_stats$polarization,\n    ris = dist_stats$ris,\n    mld = dist_stats$mld,\n    dcm = dist_stats$dcm,\n    deciles = dist_stats$deciles,\n    headcount = pov_stats$headcount,\n    poverty_gap = pov_stats$pg,\n    poverty_severity = pov_stats$p2,\n    eh = pov_stats$eh,\n    epg = pov_stats$epg,\n    ep = pov_stats$ep,\n    gh = pov_stats$gh,\n    gpg = pov_stats$gpg,\n    gp = pov_stats$gp,\n    watts = pov_stats$watts,\n    dl = pov_stats$dl,\n    ddl = pov_stats$ddl,\n    is_normal = validity$is_normal,\n    is_valid = validity$is_valid\n  )\n\n  return(out)\n}\n\n\n\n\n1.18 check_curve_validity_lb\nDescription: Check validity of Lorenz Beta fit:\n\n\nCode\ncheck_curve_validity_lb &lt;- function(headcount, A, B, C) {\n  is_valid &lt;- TRUE\n\n  for (w in seq(from = 0.001, to = 0.1, by = 0.05)) {\n    if (derive_lb(w, A, B, C) &lt; 0) {\n      is_valid &lt;- FALSE\n      break\n    }\n  }\n\n  if (is_valid) {\n    for (w in seq(from = 0.001, to = 0.999, by = 0.05)) {\n      if (DDLK(w, A, B, C) &lt; 0) { # What does DDLK stands for?? What does it do?\n        is_valid &lt;- FALSE\n        break\n      }\n    }\n  }\n\n  # WHAT IS THE RATIONAL HERE?\n  is_normal &lt;- if (!is.na(headcount)) {\n    is_normal &lt;- TRUE\n  } else {\n    is_normal &lt;- FALSE\n  }\n\n  return(list(\n    is_valid = is_valid,\n    is_normal = is_normal\n  ))\n}\n\n\nReferences: [1], [3]\nThe function tests for specific assumptions for the Lorenz Beta and relies on the formulas from Table 2 in Datt, G (1998) [3].\n\n\n1.19 DDLK\nDescription\n\n\n1.20 compute_poverty_stats_lb\nDescription\n\n\nCode\ngd_compute_poverty_stats_lb &lt;- function(mean,\n                                        povline,\n                                        A,\n                                        B,\n                                        C) {\n  # Compute headcount\n  headcount &lt;- gd_compute_headcount_lb(\n    mean = mean,\n    povline = povline,\n    A = A,\n    B = B,\n    C = C\n  )\n\n  # Poverty gap\n  u &lt;- mean / povline\n  pov_gap &lt;- gd_compute_pov_gap_lb(headcount = headcount,\n                                   A         = A,\n                                   B         = B,\n                                   C         = C,\n                                   u         = u)\n\n  # Poverty severity\n  pov_gap_sq &lt;- gd_compute_pov_severity_lb(\n    headcount = headcount,\n    pov_gap   = pov_gap,\n    A         = A,\n    B         = B,\n    C         = C,\n    u         = u\n  )\n\n  # First derivative of the Lorenz curve\n  dl &lt;- 1 - A * (headcount^B) * ((1 - headcount)^C) * (B / headcount - C / (1 - headcount))\n\n  # Second derivative of the Lorenz curve\n  ddl &lt;- A * (headcount^B) *\n    ((1 - headcount)^C) *\n    ((B * (1 - B) / headcount^2) +\n      (2 * B * C / (headcount * (1 - headcount))) +\n      (C * (1 - C) / ((1 - headcount)^2)))\n\n  # Elasticity of headcount index w.r.t mean\n  eh &lt;- -povline / (mean * headcount * ddl)\n\n  # Elasticity of poverty gap index w.r.t mean\n  epg &lt;- 1 - (headcount / pov_gap)\n\n  # Elasticity of distributionally sensitive FGT poverty measure w.r.t mean\n  ep &lt;- 2 * (1 - pov_gap / pov_gap_sq)\n\n  # PElasticity of headcount index w.r.t gini index\n  gh &lt;- (1 - povline / mean) / (headcount * ddl)\n\n  # Elasticity of poverty gap index w.r.t gini index\n  gpg &lt;- 1 + (((mean / povline) - 1) * headcount / pov_gap)\n\n  # Elasticity of distributionally sensitive FGT poverty measure w.r.t gini index\n  gp &lt;- 2 * (1 + (((mean / povline) - 1) * pov_gap / pov_gap_sq))\n\n  # Watts index\n  watts &lt;- gd_compute_watts_lb(headcount, mean, povline, 0.005, A, B, C)\n\n  return(\n    list(\n      headcount = headcount,\n      pg = pov_gap,\n      p2 = pov_gap_sq,\n      eh = eh,\n      epg = epg,\n      ep = ep,\n      gh = gh,\n      gpg = gpg,\n      gp = gp,\n      watts = watts,\n      dl = dl,\n      ddl = ddl\n    )\n  )\n}\n\n\n\n\n1.21 compute_headcount_lb\nDescription\n\n\nCode\ngd_compute_headcount_lb &lt;- function(mean, povline, A, B, C) {\n  # Compute headcount\n  headcount &lt;- rtSafe(0.0001, 0.9999, 1e-4,\n    mean = mean,\n    povline = povline,\n    A = A,\n    B = B,\n    C = C\n  )\n  # Check headcount invalidity conditions\n  if (headcount &lt; 0 | is.na(headcount)) {\n    return(NA_real_)\n  }\n\n  condition1 &lt;- is.na(BETAI(\n    a = 2 * B - 1,\n    b = 2 * C + 1,\n    x = headcount\n  ))\n  condition2 &lt;- is.na(BETAI(\n    a = 2 * B,\n    b = 2 * C,\n    x = headcount\n  ))\n  condition3 &lt;- is.na(BETAI(\n    a = 2 * B + 1,\n    b = 2 * C - 1,\n    x = headcount\n  ))\n\n  if (condition1 | condition2 | condition3) {\n    return(NA_real_)\n  }\n\n  return(headcount)\n}\n\n\n\n\n1.22 BETAI\n\n\nCode\nBETAI &lt;- function(a, b, x) {\n  if (!is.na(x)) {\n    bt &lt;- betai &lt;- 0\n\n    if (x == 0 || x == 1) {\n      bt &lt;- 0\n    } else {\n      bt &lt;- exp((a * log(x)) + (b * log(1 - x)))\n    }\n\n    if (x &lt; (a + 1) / (a + b + 2)) {\n      betai &lt;- bt * BETAICF(a, b, x) / a\n    } else if (is.na(GAMMLN(a)) || is.na(GAMMLN(b)) || is.na(GAMMLN(a + b))) {\n      betai &lt;- NA_real_\n    } else {\n      betai &lt;- exp(GAMMLN(a) + GAMMLN(b) - GAMMLN(a + b)) - (bt * BETAICF(b, a, 1 - x) / b)\n    }\n  } else {\n    betai &lt;- NA_real_\n  }\n\n  return(betai)\n}\n\n\n\n\n1.23 BETAICF\n\n\n1.24 GAMMLN\n…"
  },
  {
    "objectID": "wbpip_gd_doc.html#references",
    "href": "wbpip_gd_doc.html#references",
    "title": "Group Data Documentation (wbpip)",
    "section": "2 References",
    "text": "2 References\n\nVillasenor, J., B. C. Arnold. 1989. “Elliptical Lorenz curves”. Journal of Econometrics 40 (2): 327-338.\nKrause, M. 2013. “Corrigendum to Elliptical Lorenz curves”. Journal of Econometrics 174 (1): 44.\nDatt, G. 1998. “Computational Tools For Poverty Measurement And Analysis”. FCND Discussion Paper 50. World Bank, Washington, DC.\nRohde, N. (2008). “Lorenz Curves and Generalised Entropy Inequality Measures”. In: Chotikapanich, D. (eds) Modeling Income Distributions and Lorenz Curves. Economic Studies in Equality, Social Exclusion and Well-Being, vol 5. Springer, New York, NY.\nKakwani, N. 1980. “On a Class of Poverty Measures”. Econometrica 48 (2): 437-46."
  },
  {
    "objectID": "wbpip_gd_doc.html#appendix",
    "href": "wbpip_gd_doc.html#appendix",
    "title": "Group Data Documentation (wbpip)",
    "section": "3 Appendix",
    "text": "3 Appendix\nFind function using the following list:\n\nSection 1.1: gd_compute_pip_stats\nSection 1.2: gd_select_lorenz\ngd_compute_pip_stats_lq\ngd_compute_pip_stats_lb\ncreate_functional_form_lq\nderive_lq\ngd_estimate_lq\ncheck_curve_validity_lq\ngd_compute_dist_stats_lq"
  }
]