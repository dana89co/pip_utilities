---
title: "Group Data Documentation (wbpip)"
author: "Diana Garcia"
format: 
  html:
    number-sections: true
    mermaid:
      theme: sandstone
    code-fold: true
    code-summary: "Show the code"
---

> ## Objective {.unnumbered}
>
> This document aims to describe the functions used in `wbpip` to calculated the poverty and inequality statistics using group data.

<!-- I start by presenting the structure of the functions and then there is a description on how each function is built. -->

## Structure {.unnumbered}

```{mermaid}
flowchart TD
    lz(select_lorenz) --> stats[pip_stats]
    lq(pip_stats_lq) --> lz
    lb(pip_stats_lb) --> lz  
    form_lq(functional_form_lq) --> lq
    derive_lq(derive_lq) --> lq
    est_lq(estimate_lq) --> lq
    check_val(check_curve_validity_lq) --> est_lq
    comp_dist_lq(compute_dist_stats_lq) --> est_lq
    polarization_lq(polarization_lq) --> comp_dist_lq
    gini_lq(gini_lq) --> comp_dist_lq
    value_at_lq --> polarization_lq
    value_at_lq(value_at_lq) --> comp_dist_lq
    mld_lq(mld_lq) --> comp_dist_lq
    quantile_lq(quantile_lq) --> comp_dist_lq
    derive_lq --> comp_dist_lq
    derive_lq --> mld_lq
    derive_lq --> polarization_lq
    value_at_lq --> quantile_lq

```


## Functions

### pip_stats {#sec-pip_stats}

*Description*: Compute poverty statistics for grouped data by selecting the best functional fit for the Lorenz curve (either beta or quadratic)

::: {#nte-boundary-issue .callout-note}
#### Issue: Boundary conditions 

At the moment, this is calculated using $(\mu L'(0.001) + 4,\mu L'(0.98) - 4)$ (*Note: Not sure what is the reason of adding and subtracting 4*). 

:::

### select_lorenz {#sec-select_lorenz}

*Description*: Select best Lorenz fit and adjust the returned statistics if needed.

### pip_stats_lq

*Description*: Compute poverty statistics for grouped data using the quadratic functional form of the Lorenz qurve.

### pip_stats_lb

*Description*: Compute poverty statistics for grouped data using the beta functional form of the Lorenz qurve.

### functional_form_lq

*Description*: Prepares data for regression of $y(1-y)$ on $(x^2-y)$, $y(x-1)$ and $(x-y)$. 

*Note*: The last observation of (x,y), which by construction has the value (1, 1), is excluded since the functional form for the Lorenz curve already forces it to pass through the point (1, 1). 

*References*: [1]

*Relevant equations*:

The general Quadratic Lorenz curve form is: 

$$ax^2 + bxy + cy^2 + dx + ey + f = 0$$ {#eq-gen-equation}

where $y$ is the vector of cumulative proportion of consumption/income (L) and $x$ is the cumulative proportions of population (P). Using the conditions $f=0$ and $e = -(a+b+d+1)$ the previous equation is rewritten in a linear form as follows (Equation 15 in Villasenor et al, 1989):

$$y(1-y) = a(x^2-y) + by(x-1) + d(x-y)$$ {#eq-linear-form}

This function prepares data to estimate $a$, $b$, and $d$ (*Note*: $d$ is named $C$ in `wbpip`).


### value_at_lq: 

*Description*: Solves for the Quadratic Lorenz curves.

```{r}
value_at_lq <- function(x, A, B, C, key_values) {

  # Check for NA, Inf and negative values in x
  check_NA_Inf_values(x)
  check_neg_values(x)

  # Calculations
  # e <- -(A + B + C + 1)
  # m <- (B^2) - (4 * A)
  # n <- (2 * B * e) - (4 * C)
  temp <- (key_values$m * x^2) + (key_values$n * x) + (key_values$e^2)
  temp[temp < 0] <- 0

  # Solving the equation of the Lorenz curve
  estle <- -0.5 * ((B * x) + key_values$e + sqrt(temp))

  return(estle)
}
```

*References*: [1]

*Relevant equations*:

This function calculates the value at the Quadratic Lorenz Curve. Solving @eq-gen-equation for $y$, and assuming $f=0$ and $e = -(a+b+d+1)$ the density function that better fits income distributions will be (Equation 6b in Villasenor et al, 1989):

$$ y= \Bigl\{-(bx+e) - (\alpha x^2 + \beta x + e^2)^\frac{1}{2}\Bigl\}/2$$ {#eq-solve-y}

where $\alpha = b^2 -4a$ and $\beta = 2be - 4d$.

### derive_lq 

*Description*: returns the first derivative of the quadratic Lorenz curves with $c = 1$. 

```{r}
derive_lq <- function(x, A, B, C, key_values) {

  if (is.null(key_values)) {
    key_values <- gd_lq_key_values(A, B, C)
    # e          <- key_values$e
    # m          <- key_values$m
    # n          <- key_values$n
  }

  if (anyNA(x) == TRUE) {
    cli::cli_abort("`x' must be a numeric or integer vector")
  }
  # note:
  #   alpha --> m
  #   beta  --> n

  # e <- -(A + B + C + 1)
  # m <- (B^2) - (4 * A)
  # n <- (2 * B * e) - (4 * C) # C is called D in original paper, but C in Datt paper
  tmp <- (key_values$m * x^2) + (key_values$n * x) + (key_values$e^2)
  tmp[(!is.na(tmp) & tmp < 0)] <- 0 # If tmp == 0, val = Inf.

  # Formula for first derivative of GQ Lorenz Curve
  val <- -(B / 2) - ((2 * key_values$m * x + key_values$n) / (4 * sqrt(tmp)))

  return(val)
}
```

*References*: [1]

*Relevant equations*:

This function computes the first derivative of @eq-solve-y:

$$-(b / 2) - (\beta + 2 \alpha x) / (4\sqrt(\alpha x^2 + \beta x + e^2)$$ {#eq-first-der}

### estimate_lq

*Description*: Estimates poverty and inequality stats from Quadratic Lorenz fit

### check_curve_validity_lq

*Description*: Check validity of Lorenz Quadratic fit

*References*: [1], [2], [3]

*Relevant equations*:

The function tests for specific assumptions for the Lorenz Quadratic and relies on the formulas from Table 2 in Datt, G (1998) [3]. The nomenclature for some of these formulas differ from Villasenor et al (1989), so this is how they match:

$m = \alpha = b^2 -4a$

$n = \beta = 2be -4c$ ($c=d$ for Villasenor et al, 1989)

$r = K*2\alpha = (n^2 - 4me^2)^\frac{1}{2}$ 

::: {#nte-cond-r-issue .callout-note}
#### Issue: Rename $r$ 

At the moment, $r$ refers to $(n^2 - 4me^2)$ in `wbpip`. This is already fixed on commit `47852c` in branch `fix_key_values` by Zander (Waiting for merge). We should maybe rename this within this function. 

:::

The conditions this function tests are presented in Section 4 of Datt (1998):

Normality and Validity

 - $(n^2 - 4me^2)>0$ so the square root in $r$ to be positive. (Normality and validity)
 - $e<0$ or $c>0$ so $L(0,y) = 0$ and $L'(0^{+},y) \geq 0$ (Normality and validity)
 - $a+d \geq 0.9$ so $L(1,y) = 1$ (Validity) 

::: {#imp-condad .callout-important}
#### Issue: The inequality for $a+d$

At the moment, we still use the old validation $a+d \leq 1$. However, the Corrigendum of the original paper [2] indicates we should use $a+d \geq 1$
:::

And so $L''(x,y) \geq 0$ for $x$ within $(0,1)$:

 - $m < 0$ (condition on Villasenor et al., 1989)
 - if $m > 0$ then $m < n^2/4 e^2$ and $n \leq 0$ (last condition from Datt,1998)
 - if $m > 0$ then $m < n^2/4 e^2$ and $m < -n/2$ (last condition from Datt,1998)
 
$L''(x,y)$ can be calculated using @eq-first-der:

$$ \frac{\beta^2 -4\alpha e^2}{8(\alpha x^2 + \beta x + e^2)^\frac{3}{2}} = \frac{n^2 - 4me^2}{8(mx^2 +nx +e^2)^\frac{3}{2}}=\frac{r^2}{8(mx^2 +nx +e^2)^\frac{3}{2}} $$

### compute_dist_stats_lq

*Description*: Computes distributional stats from Lorenz Quadratic fit

::: {#nte-check1 .callout-note}
#### Check: 

What is the difference with `gd_estimate_dist_stats_lq`?

:::

### quantile_lq

*Description*: Compute quantiles from Lorenz Quandratic fit

```{r}
old_gd_compute_quantile_lq <- function(A, B, C, n_quantile = 10) {
  vec <- vector(mode = "numeric", length = n_quantile)
  x1 <- 1 / n_quantile
  q <- 0L
  lastq <- 0L
  for (i in seq_len(n_quantile - 1)) {
    q <- value_at_lq(x1, A, B, C)
    v <- q - lastq
    vec[i] <- v
    lastq <- q
    x1 <- x1 + 1 / n_quantile
  }
  vec[n_quantile] <- 1 - lastq

  return(vec)
}
```


*Note*: This function calculates the quantiles for a Lorenz Quadratic with specific values for $a$, $b$ and $d$.  

::: {#imp-quant-gd-issue .callout-important}
#### Issues:  

The description of this function indicates that it calculates the quantiles (deciles) for the density for some specific values of $a$, $b$ and $d$, but it calculates instead the "share" or the value between the deciles. If I understand correctly, the density is the lorenz curve and the share will refer to the `deciles` of the welfare vector. 

Regarding the last decile, they manually calculated it by subtracting 1 to the second-to-last decile:

`vec[n_quantile] <- 1 - value_at_lq(x[n_quantile-1], A, B, C)` where `n_quantile = 10`

However, my hypothesis is that this is related to *Issue: The inequality for $a+d$* above. If $A+C \geq 1$ then `value_at_lq(1, A, B, C) = 1`

:::

*My version of the code*:

```{r}
gd_compute_quantile_lq <- function(A, B, C, n_quantile = 10) {

  x   <- seq(from = 1/n_quantile, to = 1, by = 1/n_quantile)

  vec <- diff(c(0,value_at_lq(x, A, B, C)))

  vec[n_quantile] <- 1- value_at_lq(x[n_quantile-1], A, B, C) # Is this correct?

  return(vec)
}

```

### mld_lq

*Description*: Computes Mean Log Deviation from Lorenz Quadratic fit

```{r}
old_gd_compute_mld_lq <- function(A, B, C) {
  x1 <- derive_lq(0.0005, A, B, C)
  gap <- 0L
  mld <- 0L
  if (x1 == 0) {
    gap <- 0.0005
  } else {
    mld <- suppressWarnings(log(x1) * 0.001)
  }
  x1 <- derive_lq(0, A, B, C)
  for (xstep in seq(0, 0.998, 0.001)) {
    x2 <- derive_lq(xstep + 0.001, A, B, C)
    if ((x1 <= 0) || (x2 <= 0)) {
      gap <- gap + 0.001
      if (gap > 0.5) {
        return(-1)
      }
    } else {
      gap <- 0L
      mld <- mld + (log(x1) + log(x2)) * 0.0005
    }
    x1 <- x2
  }
  return(-mld)
}
```

*References*: None

*Note*: In this function, they do not describe how the function is calculated. The following is my hypothesis of what they were trying to accomplish:

*Relevant equations*:

The mean log deviation:

$$-\frac{1}{N} \sum_{i=1}^N ln(\frac{y_i}{\mu})=-\frac{1}{N} \sum_{i=1}^N ln(\frac{y_i}{\frac{1}{N}\sum_{i=1}^N y_i}) $$

Using the derivation from Rohde (2008) (Equation 15.20), we know that:

$$L'(\pi) = \frac{N y_k}{\sum_{k=1}^N y_k}$$


where $y_k$ is the income accruing to the $k_{th}$ individual if ordered such that $y_1<y_2<...<y_k$ and $\pi= \frac{k}{j}$. Then the mean log deviation can be rewritten as (Equation 15.21):

$$-\int_0^1 ln(L'(\pi))d\pi= \lim_{n \rightarrow \infty} -\sum_{i=1}^{N}\frac{1}{N}ln(\frac{N y_k}{\sum_{k=1}^N y_k})$$

::: {#imp-mld-gd-issue .callout-important}
#### Issue:  

My hypothesis is that they used the last formula to calculate the Mean Log Deviation. I am still unsure why they used some rules at the lower end, more specifically why they return $1$ if for the left tail of $y$ we encounter negative values. 

:::

*My version of the code*:

```{r}
gd_compute_mld_lq <- function(A, B, C) {
  x1 <- derive_lq(0.0005, A, B, C) # Not sure I understand this condition
  #gap <- 0L
  mld <- 0L
  if (x1 == 0) { # So log is not undefined
    #gap <- 0.0005
  } else {
    mld <- suppressWarnings(log(x1) * 0.001) # Needed to match test
  }

  xstep <- seq(0, 0.999, 0.001)
  x <- derive_lq(xstep, A, B, C)

  if (any(x[1:33]<=0)){ # To account for the gap and the stop parameter within the loop.
    return(-1)
  }else{
    mld <- mld + fsum( (log(x[1:999])+log(x[2:1000])) *0.0005) # Not sure why add previous mld
    return(-mld)
  }

  # x1 <- derive_lq(0, A, B, C)
  # for (xstep in seq(0, 0.998, 0.001)) {
  #   x2 <- derive_lq(xstep + 0.001, A, B, C)
  #   if ((x1 <= 0) || (x2 <= 0)) {
  #     gap <- gap + 0.001
  #     if (gap > 0.5) {
  #       return(-1)
  #     }
  #   } else {
  #     gap <- 0L
  #     mld <- mld + (log(x1) + log(x2)) * 0.0005
  #   }
  #   x1 <- x2
  # }
}
```

### gini_lq

*Description*: Compute Gini index from Lorenz Quadratic fit.

*References*: [3]

*Relevant equations*: ...

### polarization_lq

*Description*: Computes polarization index from parametric Lorenz fit

*References*: ...

*Relevant equations*: ...


## References:

1. Villasenor, J., B. C. Arnold. 1989. "[Elliptical Lorenz curves](https://doi.org/10.1016/0304-4076(89)90089-4)". *Journal of Econometrics 40* (2): 327-338.

2. Krause, M. 2013. "[Corrigendum to Elliptical Lorenz curves](https://doi.org/10.1016/j.jeconom.2013.01.001)". *Journal of Econometrics 174* (1): 44.

3. Datt, G. 1998. "[Computational Tools For Poverty Measurement And Analysis](https://www.ifpri.org/cdmref/p15738coll2/id/125673)". FCND Discussion Paper 50. World Bank, Washington, DC.

4. Rohde, N. (2008). "[Lorenz Curves and Generalised Entropy Inequality Measures](https://doi.org/10.1007/978-0-387-72796-7_15)". In: Chotikapanich, D. (eds) *Modeling Income Distributions and Lorenz Curves. Economic Studies in Equality, Social Exclusion and Well-Being*, vol 5. Springer, New York, NY. 

## Appendix: 

Find function using the following list:

-  @sec-pip_stats: `gd_compute_pip_stats`
-  @sec-select_lorenz: `gd_select_lorenz`
- `gd_compute_pip_stats_lq`
- `gd_compute_pip_stats_lb`
- `create_functional_form_lq`
- `derive_lq`
- `gd_estimate_lq` 
- `check_curve_validity_lq`
- `gd_compute_dist_stats_lq`






